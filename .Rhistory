}
for (i in 1:length(names(interestrates))){
interestrates[i] <- as.numeric(env[[names(interestrates)[i]]][datetoplotline])
}
interestrates
g_range <- range(0, interestrates)
plot(interestrates, type="l", pch=16, xlab=c("Interest Rates At Different Maturity"), ylab="Interest Rates (%)", xaxt='n', ylim = c(0,6), log = "x")
legend(1, g_range[2], datetoplotline, cex = 0.8)
axis(1, at=1:8, las=2, lab=c("3MO", "1YR", "2YR", "5YR", "7YR", "10YR", "20YR", "DGS30"), log = "x", xlim=rev(range(interestrates)))
#axis(2, las=1, at=4*0:g_range[2])
#axis(2, las=1, at=4*0:g_range[2])
box()
title(main="Dynamic Yield Curve", col.main="red", font.main=4)
runApp()
if(datetoplotline>lastdayir){
datetoplotline<-lastdayir
}
for (i in 1:length(names(interestrates))){
interestrates[i] <- as.numeric(env[[names(interestrates)[i]]][datetoplotline])
}
interestrates
g_range <- range(0, interestrates)
plot(interestrates, type="l", pch=16, xlab=c("Interest Rates At Different Maturity"), ylab="Interest Rates (%)", xaxt='n', ylim = c(0,6), log = "x")
legend(1, g_range[2], datetoplotline, cex = 0.8)
axis(1, at=1:8, las=2, lab=c("3MO", "1YR", "2YR", "5YR", "7YR", "10YR", "20YR", "DGS30"), log = rev("x"), xlim=rev(range(interestrates)))
#axis(2, las=1, at=4*0:g_range[2])
#axis(2, las=1, at=4*0:g_range[2])
box()
title(main="Dynamic Yield Curve", col.main="red", font.main=4)
if(datetoplotline>lastdayir){
datetoplotline<-lastdayir
}
for (i in 1:length(names(interestrates))){
interestrates[i] <- as.numeric(env[[names(interestrates)[i]]][datetoplotline])
}
interestrates
g_range <- range(0, interestrates)
plot(interestrates, type="l", pch=16, xlab=c("Interest Rates At Different Maturity"), ylab="Interest Rates (%)", xaxt='n', ylim = c(0,6), log = "x")
legend(1, g_range[2], datetoplotline, cex = 0.8)
axis(1, at=1:8, las=2, lab=c("3MO", "1YR", "2YR", "5YR", "7YR", "10YR", "20YR", "DGS30"), log = "x", xlim=range(interestrates))
#axis(2, las=1, at=4*0:g_range[2])
#axis(2, las=1, at=4*0:g_range[2])
box()
title(main="Dynamic Yield Curve", col.main="red", font.main=4)
if(datetoplotline>lastdayir){
datetoplotline<-lastdayir
}
for (i in 1:length(names(interestrates))){
interestrates[i] <- as.numeric(env[[names(interestrates)[i]]][datetoplotline])
}
interestrates
g_range <- range(0, interestrates)
plot(interestrates, type="l", pch=16, xlab=c("Interest Rates At Different Maturity"), ylab="Interest Rates (%)", xaxt='n', ylim = c(0,6), log = "x")
legend(1, g_range[2], datetoplotline, cex = 0.8)
axis(1, at=8:1, las=2, lab=c("3MO", "1YR", "2YR", "5YR", "7YR", "10YR", "20YR", "DGS30"), log = "x", xlim=range(interestrates))
#axis(2, las=1, at=4*0:g_range[2])
#axis(2, las=1, at=4*0:g_range[2])
box()
title(main="Dynamic Yield Curve", col.main="red", font.main=4)
if(datetoplotline>lastdayir){
datetoplotline<-lastdayir
}
for (i in 1:length(names(interestrates))){
interestrates[i] <- as.numeric(env[[names(interestrates)[i]]][datetoplotline])
}
interestrates
g_range <- range(0, interestrates)
plot(interestrates, type="l", pch=16, xlab=c("Interest Rates At Different Maturity"), ylab="Interest Rates (%)", xaxt='n', ylim = c(0,6), log = "x")
legend(1, g_range[2], datetoplotline, cex = 0.8)
axis(1, at=1:8, las=2, lab=c("3MO", "1YR", "2YR", "5YR", "7YR", "10YR", "20YR", "DGS30"), log = "x", xlim=range(interestrates))
#axis(2, las=1, at=4*0:g_range[2])
#axis(2, las=1, at=4*0:g_range[2])
box()
title(main="Dynamic Yield Curve", col.main="red", font.main=4)
if(datetoplotline>lastdayir){
datetoplotline<-lastdayir
}
for (i in 1:length(names(interestrates))){
interestrates[i] <- as.numeric(env[[names(interestrates)[i]]][datetoplotline])
}
interestrates
g_range <- range(0, interestrates)
plot(interestrates, type="l", pch=16, xlab=c("Interest Rates At Different Maturity"), ylab="Interest Rates (%)", xaxt='n', ylim = c(0,6), log = "x")
legend(1, g_range[2], datetoplotline, cex = 0.8)
axis(1, at=1:8, las=2, lab=c("3MO", "1YR", "2YR", "5YR", "7YR", "10YR", "20YR", "DGS30"), log = -"x", xlim=range(interestrates))
if(datetoplotline>lastdayir){
datetoplotline<-lastdayir
}
for (i in 1:length(names(interestrates))){
interestrates[i] <- as.numeric(env[[names(interestrates)[i]]][datetoplotline])
}
interestrates
g_range <- range(0, interestrates)
plot(interestrates, type="l", pch=16, xlab=c("Interest Rates At Different Maturity"), ylab="Interest Rates (%)", xaxt='n', ylim = c(0,6), log = "x")
legend(1, g_range[2], datetoplotline, cex = 0.8)
axis(1, at=1:8, las=2, lab=c("3MO", "1YR", "2YR", "5YR", "7YR", "10YR", "20YR", "DGS30"), log = "x", xlim=range(interestrates))
#axis(2, las=1, at=4*0:g_range[2])
#axis(2, las=1, at=4*0:g_range[2])
box()
title(main="Dynamic Yield Curve", col.main="red", font.main=4)
if(datetoplotline>lastdayir){
datetoplotline<-lastdayir
}
for (i in 1:length(names(interestrates))){
interestrates[i] <- as.numeric(env[[names(interestrates)[i]]][datetoplotline])
}
interestrates
g_range <- range(0, interestrates)
plot(interestrates, type="l", pch=16, xlab=c("Interest Rates At Different Maturity"), ylab="Interest Rates (%)", xaxt='n', ylim = c(0,6), log = "x")
legend(1, g_range[2], datetoplotline, cex = 0.8)
axis(1, at=1:8, las=2, lab=c("3MO", "1YR", "2YR", "5YR", "7YR", "10YR", "20YR", "DGS30"), log = "x", xlim=range(interestrates), reverse)
if(datetoplotline>lastdayir){
datetoplotline<-lastdayir
}
for (i in 1:length(names(interestrates))){
interestrates[i] <- as.numeric(env[[names(interestrates)[i]]][datetoplotline])
}
interestrates
g_range <- range(0, interestrates)
plot(interestrates, type="l", pch=16, xlab=c("Interest Rates At Different Maturity"), ylab="Interest Rates (%)", xaxt='n', ylim = c(0,6), log = "x")
legend(1, g_range[2], datetoplotline, cex = 0.8)
axis(1, at=1:8, las=2, lab=c("3MO", "1YR", "2YR", "5YR", "7YR", "10YR", "20YR", "DGS30"), log = "x", xlim=range(interestrates))
#axis(2, las=1, at=4*0:g_range[2])
#axis(2, las=1, at=4*0:g_range[2])
box()
title(main="Dynamic Yield Curve", col.main="red", font.main=4)
?xscale
interestrates
range(interestrates)
rev(range(interestrates))
if(datetoplotline>lastdayir){
datetoplotline<-lastdayir
}
for (i in 1:length(names(interestrates))){
interestrates[i] <- as.numeric(env[[names(interestrates)[i]]][datetoplotline])
}
interestrates
g_range <- range(0, interestrates)
plot(interestrates, type="l", pch=16, xlab=c("Interest Rates At Different Maturity"), ylab="Interest Rates (%)", xaxt='n', ylim = c(0,6), log = "x")
legend(1, g_range[2], datetoplotline, cex = 0.8)
axis(1, at=1:8, las=2, lab=c("3MO", "1YR", "2YR", "5YR", "7YR", "10YR", "20YR", "DGS30"), log = "x", xlim=rev(range(interestrates)))
#axis(2, las=1, at=4*0:g_range[2])
#axis(2, las=1, at=4*0:g_range[2])
box()
title(main="Dynamic Yield Curve", col.main="red", font.main=4)
install.packages("plotrix")
library(plotrix)
if(datetoplotline>lastdayir){
datetoplotline<-lastdayir
}
for (i in 1:length(names(interestrates))){
interestrates[i] <- as.numeric(env[[names(interestrates)[i]]][datetoplotline])
}
interestrates
g_range <- range(0, interestrates)
plot(interestrates, type="l", pch=16, xlab=c("Interest Rates At Different Maturity"), ylab="Interest Rates (%)", xaxt='n', ylim = c(0,6), log = "x")
legend(1, g_range[2], datetoplotline, cex = 0.8)
axis(1, at=1:8, las=2, lab=c("3MO", "1YR", "2YR", "5YR", "7YR", "10YR", "20YR", "DGS30"), log = "x", xlim=rev(range(interestrates)))
revaxis(xrev=TRUE)
?revaxis()
if(datetoplotline>lastdayir){
datetoplotline<-lastdayir
}
for (i in 1:length(names(interestrates))){
interestrates[i] <- as.numeric(env[[names(interestrates)[i]]][datetoplotline])
}
interestrates
g_range <- range(0, interestrates)
revaxis(interestrates, xrev=TRUE)
if(datetoplotline>lastdayir){
datetoplotline<-lastdayir
}
for (i in 1:length(names(interestrates))){
interestrates[i] <- as.numeric(env[[names(interestrates)[i]]][datetoplotline])
}
interestrates
g_range <- range(0, interestrates)
#revaxis(interestrates, xrev=TRUE)
plot(interestrates, type="l", pch=16, xlab=c("Interest Rates At Different Maturity"), ylab="Interest Rates (%)", xaxt='n', ylim = c(0,6), log = "x")
legend(1, g_range[2], datetoplotline, cex = 0.8)
axis(1, at=1:8, las=2, lab=c("3MO", "1YR", "2YR", "5YR", "7YR", "10YR", "20YR", "DGS30"), log = "x", xlim=c(8,1))
#axis(2, las=1, at=4*0:g_range[2])
#axis(2, las=1, at=4*0:g_range[2])
box()
title(main="Dynamic Yield Curve", col.main="red", font.main=4)
if(datetoplotline>lastdayir){
datetoplotline<-lastdayir
}
for (i in 1:length(names(interestrates))){
interestrates[i] <- as.numeric(env[[names(interestrates)[i]]][datetoplotline])
}
interestrates
g_range <- range(0, interestrates)
#revaxis(interestrates, xrev=TRUE)
plotCI(interestrates, type="l", pch=16, xlab=c("Interest Rates At Different Maturity"), ylab="Interest Rates (%)", xaxt='n', ylim = c(0,6), log = "x")
if(datetoplotline>lastdayir){
datetoplotline<-lastdayir
}
for (i in 1:length(names(interestrates))){
interestrates[i] <- as.numeric(env[[names(interestrates)[i]]][datetoplotline])
}
interestrates
g_range <- range(0, interestrates)
#revaxis(interestrates, xrev=TRUE)
plot(interestrates, type="l", pch=16, xlab=c("Interest Rates At Different Maturity"), ylab="Interest Rates (%)", xaxt='n', ylim = c(0,6), log = "x")
legend(1, g_range[2], datetoplotline, cex = 0.8)
axis(1, at=1:8, las=2, lab=c("3MO", "1YR", "2YR", "5YR", "7YR", "10YR", "20YR", "DGS30"), log = "x", xlim=rev(range(interestrates)))
#axis(2, las=1, at=4*0:g_range[2])
#axis(2, las=1, at=4*0:g_range[2])
box()
title(main="Dynamic Yield Curve", col.main="red", font.main=4)
runApp()
require(devtools)
install_github("slidify", "ramnathv")
install_github("slidifyLibraries", "ramnathv")
library(slidify)
author("mydeck")
slidify("index.Rmd")
knitr::opts_chunk$set(echo = TRUE)
marketopendays<-time(GSPC)
firstday<-min(marketopendays)
lastday<-max(marketopendays)
maxclose<-max(GSPC[,6])
minclose<-min(GSPC[,6])
interestratesdays<-time(DGS1)
lastdayir<-max(interestratesdays)
DateRange <- seq(firstday, lastday, by = 1) #this is needed to find the total number of days in the time series including Saturdays and Sundays
#DateRange[!DateRange %in% marketopendays] #It returns all the days not in the dataset.  Not needed at this point
numdays<-as.Date(mydate)-DateRange[1]  #Find the total number of days from mydate to the beginning of the series
numdays<-as.numeric(numdays)  #convert it to a number
numdays<-numdays+1 #The sequence starts at 1, so you need to add one to get the right answer
#DateRange[numdays]  #this is my date
#GSPC[,6][mydate]
marketcloseexists <- function(datetolookup) {
datetoplot<-datetolookup
marketcloseinmydate<-as.numeric(GSPC[,6][datetolookup])
if(identical(marketcloseinmydate, numeric(0))){
newdate<-as.Date(mydate)-1
if (identical(as.numeric(GSPC[,6][newdate]), numeric(0))){
datetoplot<-as.Date(mydate)+1
} else {
datetoplot<-newdate
}
}
return(datetoplot)
}
mydate<-as.character("2017-11-13")
datetoplotline<-marketcloseexists(mydate)
marketopendays_label=as.character(marketopendays)
plot.ts(x=marketopendays, y=GSPC[,6], ylab="S&P", xlab=c("Date"), type='l',ylim=c(minclose, maxclose))
#axis(1, at=marketopendays, las=2, cex.axis=0.85 )
abline(v=as.Date(datetoplotline), col="red", lwd=3, lty=2)
legend("topleft", as.character(datetoplotline), cex = 0.8)
Sys.Date()
mydate<-as.character("2017-10-02")
marketopendays<-time(GSPC)
firstday<-min(marketopendays)
lastday<-max(marketopendays)
maxclose<-max(GSPC[,6])
minclose<-min(GSPC[,6])
interestratesdays<-time(DGS1)
lastdayir<-max(interestratesdays)
DateRange <- seq(firstday, lastday, by = 1) #this is needed to find the total number of days in the time series including Saturdays and Sundays
#DateRange[!DateRange %in% marketopendays] #It returns all the days not in the dataset.  Not needed at this point
numdays<-as.Date(mydate)-DateRange[1]  #Find the total number of days from mydate to the beginning of the series
numdays<-as.numeric(numdays)  #convert it to a number
numdays<-numdays+1 #The sequence starts at 1, so you need to add one to get the right answer
#DateRange[numdays]  #this is my date
#GSPC[,6][mydate]
marketcloseexists <- function(datetolookup) {
datetoplot<-datetolookup
marketcloseinmydate<-as.numeric(GSPC[,6][datetolookup])
if(identical(marketcloseinmydate, numeric(0))){
newdate<-as.Date(mydate)-1
if (identical(as.numeric(GSPC[,6][newdate]), numeric(0))){
datetoplot<-as.Date(mydate)+1
} else {
datetoplot<-newdate
}
}
return(datetoplot)
}
mydate<-as.character("2017-11-13")
datetoplotline<-marketcloseexists(mydate)
marketopendays_label=as.character(marketopendays)
plot.ts(x=as.Date(marketopendays), y=GSPC[,6], ylab="S&P", xlab=c("Date"), type='l',ylim=c(minclose, maxclose))
#axis(1, at=marketopendays, las=2, cex.axis=0.85 )
abline(v=as.Date(datetoplotline), col="red", lwd=3, lty=2)
legend("topleft", as.character(datetoplotline), cex = 0.8)
marketopendays
as.Date(marketopendays)
as.Date.yearqtr(marketopendays)
as.Date.yearqtr(marketopendays)
as.Date.year(marketopendays)
?as.Date
as.Date(marketopendays, "%Y")
as.Date(marketopendays, ""%d%b%Y")
as.Date(marketopendays, ""%m%Y")
)
mydate<-as.character("2017-10-02")
marketopendays<-time(GSPC)
firstday<-min(marketopendays)
lastday<-max(marketopendays)
maxclose<-max(GSPC[,6])
minclose<-min(GSPC[,6])
interestratesdays<-time(DGS1)
lastdayir<-max(interestratesdays)
DateRange <- seq(firstday, lastday, by = 1) #this is needed to find the total number of days in the time series including Saturdays and Sundays
#DateRange[!DateRange %in% marketopendays] #It returns all the days not in the dataset.  Not needed at this point
numdays<-as.Date(mydate)-DateRange[1]  #Find the total number of days from mydate to the beginning of the series
numdays<-as.numeric(numdays)  #convert it to a number
numdays<-numdays+1 #The sequence starts at 1, so you need to add one to get the right answer
#DateRange[numdays]  #this is my date
#GSPC[,6][mydate]
marketcloseexists <- function(datetolookup) {
datetoplot<-datetolookup
marketcloseinmydate<-as.numeric(GSPC[,6][datetolookup])
if(identical(marketcloseinmydate, numeric(0))){
newdate<-as.Date(mydate)-1
if (identical(as.numeric(GSPC[,6][newdate]), numeric(0))){
datetoplot<-as.Date(mydate)+1
} else {
datetoplot<-newdate
}
}
return(datetoplot)
}
mydate<-as.character("2017-11-13")
datetoplotline<-marketcloseexists(mydate)
marketopendays_label=as.character(marketopendays)
plot.ts(y=GSPC[,6], ylab="S&P", xlab=c("Date"), type='l',ylim=c(minclose, maxclose))
#axis(1, at=marketopendays, las=2, cex.axis=0.85 )
abline(v=as.Date(datetoplotline), col="red", lwd=3, lty=2)
legend("topleft", as.character(datetoplotline), cex = 0.8)
mydate<-as.character("2017-10-02")
marketopendays<-time(GSPC)
firstday<-min(marketopendays)
lastday<-max(marketopendays)
maxclose<-max(GSPC[,6])
minclose<-min(GSPC[,6])
interestratesdays<-time(DGS1)
lastdayir<-max(interestratesdays)
DateRange <- seq(firstday, lastday, by = 1) #this is needed to find the total number of days in the time series including Saturdays and Sundays
#DateRange[!DateRange %in% marketopendays] #It returns all the days not in the dataset.  Not needed at this point
numdays<-as.Date(mydate)-DateRange[1]  #Find the total number of days from mydate to the beginning of the series
numdays<-as.numeric(numdays)  #convert it to a number
numdays<-numdays+1 #The sequence starts at 1, so you need to add one to get the right answer
#DateRange[numdays]  #this is my date
#GSPC[,6][mydate]
marketcloseexists <- function(datetolookup) {
datetoplot<-datetolookup
marketcloseinmydate<-as.numeric(GSPC[,6][datetolookup])
if(identical(marketcloseinmydate, numeric(0))){
newdate<-as.Date(mydate)-1
if (identical(as.numeric(GSPC[,6][newdate]), numeric(0))){
datetoplot<-as.Date(mydate)+1
} else {
datetoplot<-newdate
}
}
return(datetoplot)
}
mydate<-as.character("2017-11-13")
datetoplotline<-marketcloseexists(mydate)
marketopendays_label=as.character(marketopendays)
plot.ts(as.xts(GSPC[,6]), major.format="%Y", ylab="S&P", xlab=c("Date"), type='l',ylim=c(minclose, maxclose))
#axis(1, at=marketopendays, las=2, cex.axis=0.85 )
abline(v=as.Date(datetoplotline), col="red", lwd=3, lty=2)
legend("topleft", as.character(datetoplotline), cex = 0.8)
mydate<-as.character("2017-10-02")
marketopendays<-time(GSPC)
firstday<-min(marketopendays)
lastday<-max(marketopendays)
maxclose<-max(GSPC[,6])
minclose<-min(GSPC[,6])
interestratesdays<-time(DGS1)
lastdayir<-max(interestratesdays)
DateRange <- seq(firstday, lastday, by = 1) #this is needed to find the total number of days in the time series including Saturdays and Sundays
#DateRange[!DateRange %in% marketopendays] #It returns all the days not in the dataset.  Not needed at this point
numdays<-as.Date(mydate)-DateRange[1]  #Find the total number of days from mydate to the beginning of the series
numdays<-as.numeric(numdays)  #convert it to a number
numdays<-numdays+1 #The sequence starts at 1, so you need to add one to get the right answer
#DateRange[numdays]  #this is my date
#GSPC[,6][mydate]
marketcloseexists <- function(datetolookup) {
datetoplot<-datetolookup
marketcloseinmydate<-as.numeric(GSPC[,6][datetolookup])
if(identical(marketcloseinmydate, numeric(0))){
newdate<-as.Date(mydate)-1
if (identical(as.numeric(GSPC[,6][newdate]), numeric(0))){
datetoplot<-as.Date(mydate)+1
} else {
datetoplot<-newdate
}
}
return(datetoplot)
}
mydate<-as.character("2017-11-13")
datetoplotline<-marketcloseexists(mydate)
marketopendays_label=as.character(marketopendays)
plot.ts(as.xts(GSPC[,6]), major.format="%Y", ylab="S&P", xlab=c("Date"), type='l',ylim=c(minclose, maxclose))
axis(1, at=marketopendays, las=2, cex.axis=0.85, labels = format(dates,"%Y"))
abline(v=as.Date(datetoplotline), col="red", lwd=3, lty=2)
legend("topleft", as.character(datetoplotline), cex = 0.8)
mydate<-as.character("2017-10-02")
marketopendays<-time(GSPC)
firstday<-min(marketopendays)
lastday<-max(marketopendays)
maxclose<-max(GSPC[,6])
minclose<-min(GSPC[,6])
interestratesdays<-time(DGS1)
lastdayir<-max(interestratesdays)
DateRange <- seq(firstday, lastday, by = 1) #this is needed to find the total number of days in the time series including Saturdays and Sundays
#DateRange[!DateRange %in% marketopendays] #It returns all the days not in the dataset.  Not needed at this point
numdays<-as.Date(mydate)-DateRange[1]  #Find the total number of days from mydate to the beginning of the series
numdays<-as.numeric(numdays)  #convert it to a number
numdays<-numdays+1 #The sequence starts at 1, so you need to add one to get the right answer
#DateRange[numdays]  #this is my date
#GSPC[,6][mydate]
marketcloseexists <- function(datetolookup) {
datetoplot<-datetolookup
marketcloseinmydate<-as.numeric(GSPC[,6][datetolookup])
if(identical(marketcloseinmydate, numeric(0))){
newdate<-as.Date(mydate)-1
if (identical(as.numeric(GSPC[,6][newdate]), numeric(0))){
datetoplot<-as.Date(mydate)+1
} else {
datetoplot<-newdate
}
}
return(datetoplot)
}
mydate<-as.character("2017-11-13")
datetoplotline<-marketcloseexists(mydate)
marketopendays_label=as.character(marketopendays)
plot.ts(as.xts(GSPC[,6]), major.format="%Y", ylab="S&P", xlab=c("Date"), type='l',ylim=c(minclose, maxclose))
axis(1, at=marketopendays, las=2, cex.axis=0.85, labels = format(dates,"%Y-%m"))
abline(v=as.Date(datetoplotline), col="red", lwd=3, lty=2)
legend("topleft", as.character(datetoplotline), cex = 0.8)
mydate<-as.character("2017-10-02")
marketopendays<-time(GSPC)
firstday<-min(marketopendays)
lastday<-max(marketopendays)
maxclose<-max(GSPC[,6])
minclose<-min(GSPC[,6])
interestratesdays<-time(DGS1)
lastdayir<-max(interestratesdays)
DateRange <- seq(firstday, lastday, by = 1) #this is needed to find the total number of days in the time series including Saturdays and Sundays
#DateRange[!DateRange %in% marketopendays] #It returns all the days not in the dataset.  Not needed at this point
numdays<-as.Date(mydate)-DateRange[1]  #Find the total number of days from mydate to the beginning of the series
numdays<-as.numeric(numdays)  #convert it to a number
numdays<-numdays+1 #The sequence starts at 1, so you need to add one to get the right answer
#DateRange[numdays]  #this is my date
#GSPC[,6][mydate]
marketcloseexists <- function(datetolookup) {
datetoplot<-datetolookup
marketcloseinmydate<-as.numeric(GSPC[,6][datetolookup])
if(identical(marketcloseinmydate, numeric(0))){
newdate<-as.Date(mydate)-1
if (identical(as.numeric(GSPC[,6][newdate]), numeric(0))){
datetoplot<-as.Date(mydate)+1
} else {
datetoplot<-newdate
}
}
return(datetoplot)
}
mydate<-as.character("2017-11-13")
datetoplotline<-marketcloseexists(mydate)
marketopendays_label=as.character(marketopendays)
plot.ts(as.xts(GSPC[,6]), major.format="%Y-%m", ylab="S&P", xlab=c("Date"), type='l',ylim=c(minclose, maxclose))
axis(1, at=marketopendays, las=2, cex.axis=0.85, labels = format(dates,"%Y-%m"))
abline(v=as.Date(datetoplotline), col="red", lwd=3, lty=2)
legend("topleft", as.character(datetoplotline), cex = 0.8)
mydate<-as.character("2017-10-02")
marketopendays<-time(GSPC)
firstday<-min(marketopendays)
lastday<-max(marketopendays)
maxclose<-max(GSPC[,6])
minclose<-min(GSPC[,6])
interestratesdays<-time(DGS1)
lastdayir<-max(interestratesdays)
DateRange <- seq(firstday, lastday, by = 1) #this is needed to find the total number of days in the time series including Saturdays and Sundays
#DateRange[!DateRange %in% marketopendays] #It returns all the days not in the dataset.  Not needed at this point
numdays<-as.Date(mydate)-DateRange[1]  #Find the total number of days from mydate to the beginning of the series
numdays<-as.numeric(numdays)  #convert it to a number
numdays<-numdays+1 #The sequence starts at 1, so you need to add one to get the right answer
#DateRange[numdays]  #this is my date
#GSPC[,6][mydate]
marketcloseexists <- function(datetolookup) {
datetoplot<-datetolookup
marketcloseinmydate<-as.numeric(GSPC[,6][datetolookup])
if(identical(marketcloseinmydate, numeric(0))){
newdate<-as.Date(mydate)-1
if (identical(as.numeric(GSPC[,6][newdate]), numeric(0))){
datetoplot<-as.Date(mydate)+1
} else {
datetoplot<-newdate
}
}
return(datetoplot)
}
mydate<-as.character("2017-11-13")
datetoplotline<-marketcloseexists(mydate)
marketopendays_label=as.character(marketopendays)
plot.ts(as.xts(GSPC[,6]), major.format="%Y-%m", ylab="S&P", xlab=c("Date"), type='l',ylim=c(minclose, maxclose), xaxt="n")
axis(1, at=marketopendays, las=2, cex.axis=0.85, labels = format(dates,"%Y-%m"))
abline(v=as.Date(datetoplotline), col="red", lwd=3, lty=2)
legend("topleft", as.character(datetoplotline), cex = 0.8)
publish(user = "hballinas", repo = "Developing-Data-Products", host = 'github')
publish(user = "hballinas@gmail.com", repo = "Developing-Data-Products", host = 'github')
publish(user = "hballinas", repo = "Developing-Data-Products", host = 'github')
